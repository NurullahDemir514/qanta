# Qanta Personal Finance App - Cursor Rules

## Project Overview
Qanta is a modern personal finance mobile application built with Flutter, focusing on budget management, expense tracking, investment portfolio, and financial analytics with AI-powered insights.

## Tech Stack
- **Framework**: Flutter 3.8.1+
- **Language**: Dart
- **State Management**: Provider
- **Database**: Supabase
- **Navigation**: GoRouter
- **UI**: Material 3 Design System
- **Fonts**: Google Fonts (Inter)
- **Localization**: flutter_localizations (Turkish/English)
- **Theme**: Light/Dark mode with SharedPreferences
- **Responsive Design**: flutter_screenutil

## Color Palette
- **Primary**: Sophisticated Grey (#6D6D70) - Main brand color
- **Secondary**: Mint Green (#34D399) - Accent and success color
- **iOS Blue**: (#007AFF) - Interactive elements and buttons
- **Success**: Green (#4CAF50) - Positive actions and income
- **Error**: Red (#FF4C4C) - Negative actions and expenses
- **Warning**: Amber (#FFC300) - Alerts and cautions
- **Info**: Cyan (#00C2FF) - Information and transfers
- **Neutral**: Light Grey (#A0A0A0) - Secondary text and borders

## Project Structure
```
lib/
├── core/
│   ├── theme/           # Theme configuration
│   ├── services/        # External services (Supabase, etc.)
│   └── constants/       # App constants
├── modules/
│   ├── auth/           # Authentication & onboarding
│   ├── home/           # Dashboard & overview
│   ├── transactions/   # Transaction management
│   ├── cards/          # Card management
│   ├── insights/       # AI insights & analytics
│   └── settings/       # Settings & profile
├── shared/
│   ├── widgets/        # Reusable widgets
│   ├── models/         # Data models
│   └── utils/          # Utility functions
├── l10n/              # Localization files
└── routes/            # Navigation configuration
```

## SOLID Principles (MANDATORY)

### Single Responsibility Principle (SRP)
- Each class/widget must have only ONE reason to change
- Separate concerns: UI, business logic, data access
- Create focused, single-purpose classes
- Example: `TransactionFormWidget` only handles form UI, not data validation

### Open/Closed Principle (OCP)
- Open for extension, closed for modification
- Use abstract classes and interfaces
- Implement strategy pattern for different behaviors
- Example: `PaymentMethodStrategy` interface for different payment types

### Liskov Substitution Principle (LSP)
- Subclasses must be substitutable for their base classes
- Maintain contracts and behavior consistency
- Use proper inheritance hierarchies
- Example: All `TransactionType` implementations must behave consistently

### Interface Segregation Principle (ISP)
- Create small, focused interfaces
- Clients should not depend on unused methods
- Split large interfaces into smaller ones
- Example: `IReadable` and `IWritable` instead of one large `IDataAccess`

### Dependency Inversion Principle (DIP)
- Depend on abstractions, not concretions
- Use dependency injection
- Invert dependencies through interfaces
- Example: `IStockService` interface instead of direct `YandexFinanceApiService`

## Clean Architecture Guidelines

### Layer Separation
- **Presentation Layer**: UI widgets, pages, providers
- **Domain Layer**: Business logic, entities, use cases
- **Data Layer**: Repositories, data sources, models

### Dependency Rule
- Dependencies point inward only
- Outer layers can depend on inner layers
- Inner layers must not know about outer layers

## Coding Standards

### Dart/Flutter Best Practices
- Use `const` constructors whenever possible
- Prefer `final` over `var` for immutable variables
- Use meaningful variable and function names
- Follow Dart naming conventions (camelCase for variables, PascalCase for classes)
- Always use `super.key` for widget constructors
- Use `late` keyword appropriately for non-nullable variables
- Implement proper null safety

### Widget Guidelines
- Create reusable widgets in `shared/widgets/`
- Use `StatelessWidget` when possible, `StatefulWidget` only when state is needed
- Implement proper `dispose()` methods for controllers and streams
- Use `Builder` widgets to access context when needed
- Prefer composition over inheritance
- Keep widgets under 200 lines
- Extract complex widgets into separate files

### State Management
- Use Provider for global state (theme, user data)
- Use local state (setState) for simple UI state
- Create separate providers for different concerns
- Use `Consumer` and `Selector` widgets appropriately
- Implement proper error handling in providers
- Follow MVVM pattern with providers

### Navigation
- Use GoRouter for all navigation
- Define routes in `routes/app_router.dart`
- Use named routes instead of direct navigation
- Implement proper route guards for authentication
- Use type-safe navigation with extra parameters

### Styling & Theming
- Use Material 3 design system
- Follow the established color scheme
- Use Google Fonts Inter throughout the app
- Implement responsive design with flutter_screenutil
- Use Theme.of(context) for colors and text styles
- Support both light and dark themes
- Use consistent spacing and sizing

### Localization
- Add all user-facing strings to ARB files
- Use descriptive keys for localization
- Support Turkish and English languages
- Use AppLocalizations.of(context) for translations
- Never hardcode strings in UI

### File Naming
- Use snake_case for file names
- Use descriptive names that reflect functionality
- Group related files in appropriate modules
- Use suffixes: `_page.dart`, `_widget.dart`, `_provider.dart`, `_model.dart`, `_service.dart`

### Code Organization
- Keep files under 300 lines when possible
- Separate business logic from UI
- Use barrel exports (index.dart) for modules
- Group imports: Flutter, packages, relative imports
- Use meaningful comments for complex logic
- Follow single responsibility per file

### Error Handling
- Implement try-catch blocks for async operations
- Show user-friendly error messages
- Log errors appropriately (debugPrint in development)
- Handle network connectivity issues
- Validate user inputs
- Use Result<T> pattern for error handling

### Performance
- Use `const` widgets to reduce rebuilds
- Implement lazy loading for lists
- Optimize images and assets
- Use `ListView.builder` for large lists
- Avoid unnecessary rebuilds with proper state management
- Use `RepaintBoundary` for complex widgets
- Implement proper caching strategies

### Security
- Never commit API keys or sensitive data
- Use environment variables for configuration
- Implement proper input validation
- Follow Supabase security best practices
- Use secure storage for sensitive data
- Implement proper authentication flows

### Testing
- Write unit tests for business logic
- Write widget tests for UI components
- Use meaningful test descriptions
- Mock external dependencies
- Aim for good test coverage
- Test error scenarios

## Finance App Specific Guidelines

### Data Models
- Create models for: User, Transaction, Card, Budget, Category, QuickNote
- Use proper data validation
- Implement serialization methods (toJson/fromJson)
- Use enums for transaction types, categories
- Implement proper equality and hashCode

### Financial Calculations
- Use `Decimal` or `BigDecimal` for precise calculations
- Handle currency formatting properly
- Implement proper rounding for financial values
- Support multiple currencies
- Validate financial inputs

### UI/UX for Finance
- Use clear visual hierarchy for financial data
- Implement proper loading states
- Show confirmation dialogs for important actions
- Use appropriate icons for financial concepts
- Implement pull-to-refresh for data updates
- Use consistent number formatting

### Security for Finance
- Implement biometric authentication
- Use secure storage for sensitive financial data
- Implement session timeouts
- Add transaction confirmation steps
- Log financial operations for audit
- Encrypt sensitive data

## AI Integration Guidelines
- Use clear prompts for AI financial insights
- Implement proper error handling for AI responses
- Show loading states during AI processing
- Cache AI responses when appropriate
- Provide fallback content when AI is unavailable
- Implement proper rate limiting

## Git Workflow
- Use conventional commits (feat:, fix:, docs:, etc.)
- Create feature branches for new functionality
- Write descriptive commit messages
- Keep commits atomic and focused
- Use pull requests for code review
- Follow semantic versioning

## Dependencies Management
- Keep dependencies up to date
- Use specific version numbers in pubspec.yaml
- Document why each dependency is needed
- Prefer official packages over third-party when possible
- Regular security audits of dependencies
- Use dependency injection

## Documentation
- Document complex business logic
- Keep README.md updated
- Document API integrations
- Maintain changelog for releases
- Document deployment procedures
- Use dartdoc for public APIs

## Code Review Checklist
- [ ] Follows SOLID principles
- [ ] Follows Clean Architecture
- [ ] Follows Dart/Flutter best practices
- [ ] Proper error handling implemented
- [ ] Localization strings added
- [ ] Theme support implemented
- [ ] Performance considerations addressed
- [ ] Security guidelines followed
- [ ] Tests written (if applicable)
- [ ] Documentation updated
- [ ] No hardcoded values
- [ ] Proper null safety
- [ ] Responsive design implemented
- [ ] Accessibility considerations

## Quick Notes Specific Rules
- Use bottom sheet for note creation
- Implement proper image handling
- Support text and image notes
- Implement smart analysis for transaction conversion
- Use proper state management for note operations
- Implement proper error handling for media operations

## Stock Management Rules
- Implement proper real-time price updates
- Use proper error handling for API calls
- Implement offline support
- Use proper caching strategies
- Implement proper loading states
- Handle market hours properly

## Savings Goals (Birikimler) Rules
- Implement goal-based savings system with visual progress tracking
- Support multiple savings goals with customizable emojis, colors, and target amounts
- Integrate with existing account system for deposits/withdrawals
- Implement milestone achievements (25%, 50%, 75%, 100%)
- Support auto-transfer and round-up features (Premium)
- Use Firebase for data persistence with proper security rules
- Follow event-driven architecture for balance updates
- Implement smart AI suggestions for savings optimization
- Support goal categories (emergency, vacation, shopping, etc.)
- Provide comprehensive transaction history per goal
- Use animated progress indicators and celebration animations
- Implement proper notification system for milestones and reminders
- Free users: max 3 active goals, Premium: unlimited
- Integrate with Cards screen as 4th tab (Cash, Debit, Credit, Savings)
- Show summary cards on Home screen for quick overview
- Support goal archiving and completion tracking
- Implement proper validation (target > 0, current >= 0)
- Use proper currency formatting and calculations
- Support goal images/photos (Premium feature)
- Implement daily/weekly/monthly progress analytics

### Savings Data Models
- Create `SavingsGoal` model with all properties (name, emoji, target, current, etc.)
- Create `SavingsTransaction` model for deposits/withdrawals
- Create `AutoTransferSettings` for automatic transfers
- Create `RoundUpSettings` for round-up savings
- Create `NotificationSettings` for goal reminders
- Create `Milestone` model for achievement tracking
- Use enums: `SavingsGoalCategory`, `SavingsTransactionType`, `TransferFrequency`

### Savings Services
- `SavingsService`: CRUD operations for goals
- `SavingsTransactionService`: Handle deposits, withdrawals, transfers
- `SavingsCalculatorService`: Calculate daily requirements, AI suggestions
- `SavingsMilestoneService`: Track and award milestones
- `SavingsNotificationService`: Handle reminders and notifications
- Follow existing service patterns (Firebase integration, error handling)

### Savings UI Components
- `SavingsTab`: Main tab in Cards screen
- `SavingsGoalCard`: Individual goal card widget with gradient and progress
- `SavingsGoalDetailScreen`: Detailed view with transactions and analytics
- `AddSavingsGoalForm`: Create new goal form
- `EditSavingsGoalForm`: Edit existing goal
- `SavingsDepositForm`: Deposit money to goal
- `SavingsWithdrawForm`: Withdraw from goal
- `SavingsSummarySection`: Home screen summary widget
- `SavingsMilestoneDialog`: Celebration dialog for achievements
- Use Material 3 design with iOS-style polish
- Implement smooth animations and transitions
- Support both light and dark themes

### Savings Premium Features
- Free: Max 3 active goals, manual deposits only
- Premium: Unlimited goals, auto-transfer, round-up, goal images, advanced analytics
- Implement proper premium gates with upgrade prompts
- Use PremiumService for feature access control

### Savings Events
- Create `SavingsEvents` class following existing event pattern
- Events: GoalCreated, GoalUpdated, GoalDeleted, GoalCompleted
- Events: Deposit, Withdraw, MilestoneAchieved
- Integrate with existing UnifiedProviderV2

### Savings Localization
- Add all savings-related strings to intl_en.arb and intl_tr.arb
- Keys: savingsGoals, addGoal, targetAmount, currentAmount, etc.
- Support plurals for goal counts
- Localize milestone achievements and notifications

Remember: Focus on creating a secure, user-friendly, and performant personal finance application that follows SOLID principles and Clean Architecture patterns. Every line of code should be maintainable, testable, and follow these guidelines.